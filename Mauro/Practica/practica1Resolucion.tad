// Práctica 1

// Ejercicio 1

// a
duplicar : secu(α) -> secu(α)
duplicar(<>) ≡ <>
duplicar(x • s) ≡ x • x • duplicar(s) 

// b
// no se entiende que hacer

// c
reverso : secu(α) -> secu(α)
reverso(<>) ≡ <>
reverso(x • s) ≡ reverso(s) • x

// d
capicua : secu(α) × secu(α) -> bool
capicua(s) ≡ reverso(s) = s

// e
esPrefijo? : secu(α) × secu(α) -> bool
esPrefijo?(<>, t) ≡ true
esPrefijo?(x • s, t) ≡ if vacia?(t) then false else x=prim(t) ∧ esPrefijo?(s, fin(t)) fi

// f 
Buscar : secu(α) × secu(α) -> Nat 
Buscar(<>, t) ≡ 0
Buscar(x • s, t) ≡ if ¬vacia?(t) then
											if ¬esPrefijo?(x • s, t) then 1 + Buscar(x • s, fin(t)) else 0 fi
									 fi  
									 
// g 
EstaOrdenada? : secu(α) -> bool
EstaOrdenada? (<>) ≡ true
EstaOrdenada? (x • s) ≡ if vacia?(s) then true else x < prim(s) ∧ EstaOrdenada?(s) fi

// h
InsertarOrdenada : secu(α) s0 × α -> secu(α)   {EstaOrdenada?(s0) = true}
InsertarOrdenada (<>, e) ≡ <e>
InsertarOrdenada (x • s, e) ≡ if x > e then (e • x • s) else (x • InsertarOrdenada(s, e)) fi

// i 
CantidadApariciones : secu(α) × α -> Nat 
CantidadApariciones (<>, e) ≡ 0
CantidadApariciones (x • s, e) ≡ if x = s then
																	1 + CantidadApariciones(s, e)
																 else
																 	CantidadApariciones(s, e)
																 fi

// j
esPermutacion? : secu(α) × secu(α) -> bool
esPermutacion (<>, t) ≡ long(t) = 0
esPermutacion (x • s, t) ≡  // No salio

// k
Combinar : secu(α) a × secu(α) b -> secu(α)  {EstaOrdenada?(a) ∧ EstaOrdenada?(b) = true}
Combinar (<>, t) = t
Combinar (x • s, t) ≡ 
											if ¬vacia?(t) then
												if x < prim(t) then
													x • Combinar(s, t)
												else
													prim(t) • Combinar(s, fin(t))
												fi
											else
												x • s
											fi
											
											
// Ejercicio 2

// a
#Hojas : ab(α) -> Nat
#Hojas (nil) ≡ 0
#Hojas (bin(i, r, d)) ≡ if esHoja?(bin(i,r,d)) then 1 else #Hojas(r) + #Hojas(i) fi 

// b 
DegeneradoAIzquierda: ab(α) -> Bool
DegeneradoAIzquierda(a) ≡ nil?(a) ∨L if esHoja?(a) 
																			then true 
																			else nil?(der(a)) ∧ DegeneradoAIzquierda(izq(a))
																		 fi

// c
ZigZag: ab(α) -> Bool
ZigZag(a) ≡ nil?(a) ∨L esHoja?(a) ∨L 
						if nil?(izq(a))
									then nil?(der(der(a))) ∧ ZigZag(der(a))
									else 
										if nil?(izq(a))
										then ZigZag(der(a))
									  else false
									  fi
					  fi
						
// d)
UltimoNivelCompleto: ab(α) -> nat
UltimoNivelCompleto(a) ≡ if nil?(a)
														then 0
												else 1 + min(UltimoNivelCompleto ( izq(a) ), UltimoNivelCompleto (der(a) ))
																			
// e)
Espejo: ab(α) -> ab(α)
Espejo(a) ≡ if nil?(a)
							then a
							else bin( Espejo (der(a), raiz(a), Espejo (izq(a))))
						fi
												
// f)
EsSimetrico?: ab(α) -> Bool
EsSimetrico?(a) ≡ a = Espejo(a)

// Ejercicio 3
// a)
agregarTodos: α x conj(conj(α)) -> conj(α)
agregarTodos(n, c) ≡ if Ø?(c)
		then Ag(Ag(n, Ø), Ø)
		else Ag(Ag(n, dameUno(c)), agregarTodos(n, sinUno(c)))
																 fi

PartesDe: conj(α) -> conj(conj(α))
PartesDe(c) ≡ if Ø?(c) then c
					    	else agregarTodos(dameUno(c), PartesDe(sinUno(c))) ∪ PartesDe(sinUno(c))
							fi
											

											
// 4
// PREGUNTAR ESTE Ejercicio

// 5
// α
NivelNormal? : at(α) × Int k-> Bool   { k>=1 }
NivelNormal? (a, k) ≡
	if nil?(a) then
		false
	else
		if k=1 then
			¬nil(med(a)) ∧ ¬nil(der(a)) ∧ ¬nil(izq(a))
		else
			NivelNormal(med(a), k-1) ∧ NivelNormal(izq(a), k-1) ∧ NivelNormal(der(a), k-1)
		fi
	fi			
	
// b
//Consultar

Acotado? : at(α) × Int -> Bool   { k>=1 }
Acotado (a, k) ≡ 
		if nil?(a) then
			true
		else
			if #NodosHijos(a) < k then
				 Acotado()
			else
				false
			fi
		fi										 																								 



// 6
// α
ramaMasAlta : α × secu(rosetree(α)) -> rosetree(alpha) 
ramaMasAlta(r, e • s) ≡ 
	if vacia?(e • s) then
		rosetree(r, <>)
	else
		if altura(e) > altura(ramaMasAlta(r, s))  then
			e
		else
			ramaMasAlta(r, s)
		fi
	fi

altura : rosetree(α) -> Nat 
altura(rose(a, b)) ≡ 
	if vacia?(b) then
		1
	else
		1 + ramaMasAlta(r, b)
	fi

// b  preguntar si esta bien (mi idea)
esHoja? : rosetree(α) -> bool
esHoja? (rose(r, b)) ≡ vacia?(b)

#CantHojas : rosetree(α) -> Nat 
#CantHojas (rose(a, b)) ≡ if vacia?(b) then 
													1 else 
															if esHoja(prim(b)) then 1 + #CantHojas(rose(a, fin(b))) else #CantHojas(rose(a, fin(b))) fi 
													fi
											
													
// c preguntar si esta ok
podar : rosetree(α) a-> rosetree(α)   {¬esHoja(a)}
podar (rose(a, b)) ≡ 
	if esHoja(prim(b)) then
		podar(rose(a, fin(b)))
	else
		rose(a, prim(b) • podar(fin(b)))
	fi
	

// d preguntar si esta ok
ramasMenorOIgual : α n × rosetree(α) -> secu(secu(α))  {n >= 1}
ramasMenorOIgual (n, rose(r, h)) ≡ 
	if n = 1 then
		<r>
	else
		if vacia?(h)) then
			<r>
		else
			insertarATodos(r, ramasMenorOIgual(n - 1, h))
		fi
	fi
	

insertarATodos : α × secu(secu(α)) -> secu(α)
insertarATodos (a, b) ≡ 
	if vacia?(b) then
		<>
	else
		(a • prim(b)) • insertarATodos(a, fin(b))
	fi
	
	
// e preguntar si esta ok
elementosDelNivel : α n × rosetree(α) -> secu(α) {n >= 1}
elementosDelNivel (n, rose(r, h)) ≡ nivelN(ramasMenorOIgual(n, rose(r, h)))

nivelN : α n × secu(secu(α)) -> secu(α)  {n >= 1}
nivelN (n, ramas) ≡ 
	if vacia?(ramas) then
		<>
	else
		if long(prim(ramas)) = n then
			ult(prim(ramas)) • nivelN(n, fin(ramas))
		else
			nivelN(n, fin(ramas))
		fi
	fi
	
// f preguntar si esta ok
ramasMasLargasConRepetidos : rosetree(α) -> conj(secu(α))
ramasMasLargasConRepetidos (r) ≡ conjRamasConRepetidos(ramasDeNivelN(ramasMenorOIgual(altura(r), r)))

ramasDeNivelN : α n × secu(secu(α)) -> secu(secu(α))  {n >= 1}
ramasDeNivelN (n, ramas) ≡ 
	if vacia?(ramas) then
		<>
	else
		if long(prim(ramas)) = n then
		 	prim(ramas) • ramasDeNivelN(n, fin(ramas))
		else
			ramasDeNivelN(n, fin(ramas))
		fi
	fi
	
conjRamasConRepetidos : secu(secu(α)) -> conj(secu(α))
conjRamasConRepetidos (ramas) ≡ 
	if vacia?(ramas) then
		Ø
	else
		if tieneRepetidos(prim(ramas)) then
			Ag(prim(ramas), conjRamasConRepetidos(fin(ramas)))
		else
			 conjRamasConRepetidos(fin(ramas))
		fi
	fi
	
tieneRepetidos : secu(α) -> Bool
tieneRepetidos (x) ≡ 
		if vacia?(x) then
			false
		else
			if CantidadApariciones(prim(x), fin(x)) > 0 then
				true
			else
				tieneRepetidos(fin(x))
			fi
		fi
		


// PARTE 2 
//7
TAD Polinomios
	Axiomas:
		Evaluar(Cte(const), n) ≡ const
		Evaluar(X, n) ≡ n
		Evaluar(a + b, n) ≡ Evaluar(a, n) + Evaluar(b, n)
		Evaluar(a . b, n) ≡ Evaluar(a, n) . Evaluar(b, n)

		esRaiz? : polinomio × nat -> Bool
		esRaiz(p, n) ≡ 0 = Evaluar(p, n)
Fin TAD

//8 
TAD ROBOT
	Axiomas:
	Trayectoria (Ubicar(c)) ≡ <c> 
	Trayectoria (Arriba(r)) ≡ Trayectoria(r) • < π1(PosiciónActual(r) + 1), π2(PosiciónActual(r)) >
	Trayectoria (Abajo(r)) ≡ Trayectoria(r) • < π1(PosiciónActual(r) - 1), π2(PosiciónActual(r)) >
	Trayectoria (Derecha(r)) ≡ Trayectoria(r) • < π1(PosiciónActual(r)), π2(PosiciónActual(r) + 1) >
	Trayectoria (Izquierda(r)) ≡ Trayectoria(r) • < π1(PosiciónActual(r)), π2(PosiciónActual(r) - 1) >

	PosiciónActual : robot -> coordenada
	PosiciónActual(r) ≡ ult(Trayectoria(r))

	CuantasVecesPasó : coordenada × robot -> nat 
	CuantasVecesPasó (c, r) ≡ CantidadApariciones(c, Trayectoria(r))

	MásALaDerecha : robot -> coordenada
	MásALaDerecha (r) ≡ 
		if long(Trayectoria(r)) = 1 then
			prim(Trayectoria(r))
		else
			if π2(prim(Trayectoria(r))) > π2(MásALaDerecha(fin(Trayectoria(r))))   then
				prim(Trayectoria(r))
			else
				MásALaDerecha(fin(Trayectoria(r)))
			fi
		fi
Fin TAD

//9
TAD ELECTROIMÁN
	Axiomas:
		Cinta(Arrancar(c)) ≡ c
		Cinta(Prender(e)) ≡ if  then SacarElem(Cinta(e)) else Cinta(e) fi
		Cinta(Apagar(e)) ≡ if imanCargado?(e) then PonerElem(Cinta(e)) else Cinta(e) fi 
		Cinta(<-(e)) ≡ <-(Cinta(e))
		Cinta(->(e)) ≡ ->(Cinta(e))
		
		ImánPrendido?(Arrancar(c)) ≡ true
		ImánPrendido?(Prender(e)) ≡ true
		ImánPrendido?(Apagar(e)) ≡ false
		ImánPrendido?(<-(e)) ≡ ImánPrendido(e)
		ImánPrendido?(->(e)) ≡ ImánPrendido(e)
		
		ImánCargado?(Arrancar(c)) ≡ false
		ImánCargado?(Prender(e)) ≡ CeldaActualOcupada?(e)
		ImánCargado?(Apagar(e)) ≡ false
		ImánCargado?(<-(e)) ≡ ImánCargado(e) ∨ CeldaActualOcupada(<-(e))
		ImánCargado?(->(e)) ≡ ImánCargado(e) ∨ CeldaActualOcupada(->(e))
		
		CeldaActualOcupada? (e) ≡ CeldaActualOcupada?(Cinta(e))
		
		#Giros<-(e) ≡ #Giros<-(Cinta(e))
		#Giros->(e) ≡ #Giros->(Cinta(e))
Fin TAD 

TAD Cinta
	Axiomas:
		#Celdas(Arrancar(n)) ≡ n 
		#Celdas(PonerElem(c)) ≡ #Celdas(c)
		#Celdas(SacarElem(c)) ≡ #Celdas(c)
		#Celdas(<-(c)) ≡ #Celdas(c)
		#Celdas(->(c)) ≡ #Celdas(c)
		
		CeldaOcupada?(n, Arrancar(n)) ≡ CeldaOcupada?(n, Arrancar(n))
		CeldaOcupada?(n, PonerElem(c)) ≡ CeldaActual = n ∨ CeldaOcupada(n, )
		CeldaOcupada?(n, PonerElem(c)) ≡ CeldaActual = n
Fin TAD


	
